import java.util.*;

/**
 * Represents an AI player in the game, an AI player is a virtual player that simulates a real player
 * in the game of scrabble. An AI player can place tiles to form a word on the board, pass and swap.
 * The AI's object just like the players objective is to win the game by gathering the most points.
 *
 * Author(s): Rami Ayoub, Louis Pantazopoulos, Andrew Tawfik, Liam Bennet
 * Version: 5.0
 * Date: Tuesday, December 3, 2024
 */

public class AIPlayer extends Player {

    private static final String BLANK_TILE = " "; //represents the letter of a blank tile
    private static final int MIN_WORD_LENGTH = 2; //the minimum word length that can be generated by the AIPlayer

    /**
     * This is the constructor of the AIPlayer class which extends from the player class.
     * It calls the super method to initiate a player where each AIPlayer will have a special tag
     * to differentiate them form the other AI.
     * @param AITag the name of the AIPlayer ie, AI1, AI2, etc.
     */
    public AIPlayer(String AITag) {
        super(AITag);
    }

    /**
     * Get all possible word computations from the tiles of the AIPlayer. If
     * an AIPlayer has a blank tile then it randomly chooses a letter.
     * It will return a set of the word computations in descending order of length.
     *
     * @param wordList the wordlist of valid words
     * @return a set of all word computations in ascending order.
     */
    public HashSet<String> getAllWordComputations(WordList wordList) {
        HashSet<String> validWords = new HashSet<>(); //creates a new set that will have all valid words to be returned
        String tilesAsString = getTilesToString(); //gets the AIPlayers tiles as a string

        boolean hasBlankTile = tilesAsString.contains(BLANK_TILE); //Checks to see if we have a blank tile

        for(int length = getTiles().size(); length >= MIN_WORD_LENGTH; length--){ //traverses to get all possible words from number of tiles to 2
            //if there is a blank then calls a function to generate permutations with a blank, else calls a function to generate permutations without a blank and returns a set of permuations
            HashSet<String> allPermutations = hasBlankTile ? generateAllBlankPermutations(tilesAsString, length): generatePermutations(tilesAsString, length);
            for(String word : allPermutations){ //traverses through the permutation of words that were created
                if(wordList.isValidWord(word)){ //checks to see if the word was valid from the wordlist
                    validWords.add(word); //adds it to the valid word set
                }
            }
        }
        return validWords; //returns the set of word permutation that are also valid in the word list
    }

    /**
     * When there is a blank tile, calls a function to generate a random letter. The blank tile is
     * selected to be a random letter. Then it calls a function to generate all word permutations for a given length
     * @param tilesAsString the tiles of the AIPlayer as a string
     * @param length the desired length for the permutations
     * @return returns a hashset of all possible permutations.
     */
    private HashSet<String> generateAllBlankPermutations(String tilesAsString, int length) {
        HashSet<String> permutations = new HashSet<>(); //creates and initialized a hashset
        char randomLetter = getRandomLetter(); //gets a random letter to replace for the blanks tile
        String replacedTiles = tilesAsString.replaceFirst(BLANK_TILE, String.valueOf(randomLetter)); //returns a string that replaces the blank tile with the randomly selected letter.
        permutations.addAll(generatePermutations(replacedTiles, length)); //generates permutations for the replaced tiles at a given length and adds it to the hashset
        return permutations; //returns the hashset of permutations
    }

    /**
     * Gets a random letter to replace the blank tile.
     */
    private char getRandomLetter() {
        Random rand = new Random(); //creates a random object
        return (char) ('A' + rand.nextInt(26)); //returns a random letter from A to Z
    }

    /**
     * Generates all possible permutations for a given length from the tilesAsString of the AIPlayer tiles.
     * @param tilesAsString the string representation of the AIPlayer's tiles.
     * @param length the desired length for the word permutations.
     * @return a hashset containing all word permutations for a desired length.
     */
    private HashSet<String> generatePermutations(String tilesAsString, int length) {
        HashSet<String> permutations = new HashSet<>(); //creates and initializes a new hashset
        permuteRecursive(tilesAsString.toCharArray(), length, "", permutations); //calls a recursive function that generates all word permutations for a desired length
        return permutations; //returns the hashset containing all word permutations for a given length
    }

    /**
     * A recursive function that generates permutations for a given length.
     *
     * @param tilesAsCharList a list of char for the tiles of the AIPlayer.
     * @param length the desired length for the permutations.
     * @param currentWord the current string word that is constructed during the recursive call.
     * @param permutations the hashset that stores all the word computation for the length.
     */
    private void permuteRecursive(char[] tilesAsCharList, int length, String currentWord, HashSet<String> permutations) {
        if (currentWord.length() == length) { //the base case when the current string matches the desired length
            permutations.add(currentWord); //appends the permutation to the Hashset
            return;
        }
        for (int i = 0; i < tilesAsCharList.length; i++) { //iterates through the char list of the AIPlayers tiles as letters
            char[] remainingTiles = new char[tilesAsCharList.length - 1]; //creates a new char list that doesn't include the char tile at that index
            System.arraycopy(tilesAsCharList, 0, remainingTiles, 0, i); //copies char tiles before that index to the new array
            System.arraycopy(tilesAsCharList, i + 1, remainingTiles, i, tilesAsCharList.length - i - 1); //copies char tiles after that index to the new array
            permuteRecursive(remainingTiles, length, currentWord + tilesAsCharList[i], permutations); //builds the current string and calls the function for the remaining char tiles
        }
    }

    /**
     * Generates and returns a string that represents the AIPlayers Tiles.
     */
    public String getTilesToString() {
        StringBuilder tilesAsString = new StringBuilder(); //creates a new string builder
        for (Tiles t : getTiles()) { //traverses through the tiles of the AIPlayer
            tilesAsString.append(t.getLetter()); //adds each tile letter to the string builder
        }
        return tilesAsString.toString(); //returns the to string of the string builder
    }
}